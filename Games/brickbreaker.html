<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brick Breaker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #0d1117; /* Darker background */
            color: #e0e0e0;
            overflow: hidden;
            touch-action: none; /* Prevents scrolling on touch devices */
        }
        canvas {
            background-color: transparent; /* Let body background show through for trail effect */
            display: block;
            border-radius: 0.5rem;
        }
        .canvas-wrapper {
             background: #16213e;
             border-radius: 0.5rem;
             box-shadow: 0 0 30px rgba(0, 255, 255, 0.6), inset 0 0 15px rgba(0,0,0,0.5);
             padding: 0;
             line-height: 0;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #1a1a2e;
            border: 2px solid #0f3460;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 225, 255, 0.7);
            animation: fadeIn 0.5s;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        .modal-button {
            background-color: #e94560;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin-top: 20px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s, transform 0.2s;
        }
        .modal-button:hover {
            background-color: #f05a74;
            transform: scale(1.05);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center h-screen m-0">

    <!-- Game Header -->
    <div class="w-full max-w-4xl flex justify-between items-center p-4 text-white">
        <h1 class="text-2xl md:text-3xl tracking-widest text-cyan-300">BRICK BREAKER</h1>
        <div class="text-lg md:text-xl text-right">
            <div>SCORE: <span id="score">0</span></div>
            <div>LIVES: <span id="lives">3</span></div>
        </div>
    </div>

    <!-- Canvas Wrapper for background and effects -->
    <div class="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Start/Game Over Modal -->
    <div id="gameModal" class="modal flex">
        <div class="modal-content">
            <h2 id="modalTitle" class="text-4xl mb-4 text-cyan-300">Ready?</h2>
            <p id="modalMessage" class="text-lg mb-6">Break the bricks. Catch the power-ups!</p>
            <button id="modalButton" class="modal-button">Start Game</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const livesElement = document.getElementById('lives');
            const gameModal = document.getElementById('gameModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalMessage = document.getElementById('modalMessage');
            const modalButton = document.getElementById('modalButton');

            // --- Game State ---
            let gameState = 'paused';
            let score = 0;
            let lives = 3;
            let animationFrameId;

            // --- Audio Synthesis with Tone.js ---
            const synth = new Tone.Synth().toDestination();
            const metalSynth = new Tone.MetalSynth({ frequency: 50, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 3.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination();
            const hitSound = () => synth.triggerAttackRelease("C5", "8n");
            const strongHitSound = () => metalSynth.triggerAttackRelease("C4", "8n");
            const paddleSound = () => synth.triggerAttackRelease("G4", "8n");
            const wallSound = () => synth.triggerAttackRelease("C4", "8n");
            const loseLifeSound = () => synth.triggerAttackRelease("C3", "4n");
            const powerupSound = () => synth.triggerAttackRelease("G5", "8n");

            // --- Game Objects & Arrays ---
            let balls = [];
            let particles = [];
            let powerUps = [];
            const paddle = { x: 0, y: 0, width: 0, height: 0, baseWidth: 0 };
            const brickInfo = { rowCount: 5, columnCount: 11, width: 0, height: 0, padding: 5, offsetTop: 50, offsetLeft: 30 };
            let bricks = [];
            const brickColors = ["#e94560", "#f8b400", "#50c878", "#0abde3", "#9b59b6"];

            // --- Canvas Sizing ---
            function resizeCanvas() {
                const parent = document.querySelector('.canvas-wrapper');
                const availableHeight = window.innerHeight - 150;
                const availableWidth = window.innerWidth * 0.9;

                let canvasWidth = Math.min(availableWidth, 1000);
                let canvasHeight = canvasWidth / 2;

                if (canvasHeight > availableHeight) {
                    canvasHeight = availableHeight;
                    canvasWidth = canvasHeight * 2;
                }
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                parent.style.width = `${canvasWidth}px`;
                parent.style.height = `${canvasHeight}px`;

                if (gameState !== 'playing') {
                     resetGame(false);
                }
            }

            // --- Game Element Creation ---
            function createBall(x, y, dx, dy, speed) {
                 const newBall = {
                    x: x,
                    y: y,
                    radius: Math.min(canvas.width, canvas.height) / 50,
                    speed: speed,
                    dx: dx,
                    dy: dy
                };
                return newBall;
            }

            function resetBallAndPaddle() {
                paddle.width = paddle.baseWidth;
                paddle.x = (canvas.width - paddle.width) / 2;

                balls = [];
                const ballSpeed = canvas.width / 250;
                const initialDx = ballSpeed * (Math.random() < 0.5 ? 1 : -1);
                balls.push(createBall(canvas.width / 2, paddle.y - 20, initialDx, -ballSpeed, ballSpeed));
            }

            function createBricks() {
                bricks = [];
                for (let c = 0; c < brickInfo.columnCount; c++) {
                    bricks[c] = [];
                    for (let r = 0; r < brickInfo.rowCount; r++) {
                        const brickX = (c * (brickInfo.width + brickInfo.padding)) + brickInfo.offsetLeft;
                        const brickY = (r * (brickInfo.height + brickInfo.padding)) + brickInfo.offsetTop;
                        // First two rows are stronger
                        const health = r < 2 ? 2 : 1;
                        bricks[c][r] = { x: brickX, y: brickY, status: 1, health: health, baseColor: brickColors[r] };
                    }
                }
            }

            // --- Particle System ---
            function createParticles(x, y, color) {
                const particleCount = 20;
                for (let i = 0; i < particleCount; i++) {
                    particles.push({
                        x: x,
                        y: y,
                        radius: Math.random() * 2 + 1,
                        color: color,
                        dx: (Math.random() - 0.5) * 4,
                        dy: (Math.random() - 0.5) * 4,
                        life: 50,
                        alpha: 1
                    });
                }
            }

            // --- Power-Up System ---
            function createPowerUp(x, y) {
                const types = ['W', 'M']; // W = Wide, M = Multi-ball
                const type = types[Math.floor(Math.random() * types.length)];
                powerUps.push({
                    x: x,
                    y: y,
                    size: 10,
                    dy: 2,
                    type: type,
                    color: '#00ffcc'
                });
            }

            // --- Drawing Functions ---
            function drawBallTrail() {
                 ctx.fillStyle = 'rgba(22, 33, 62, 0.25)'; // Motion blur effect
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            function drawBalls() {
                balls.forEach(ball => {
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                    ctx.fillStyle = "#ffffff";
                    ctx.shadowColor = '#fff';
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.closePath();
                    ctx.shadowBlur = 0;
                });
            }

            function drawPaddle() {
                ctx.beginPath();
                ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
                ctx.fillStyle = "#e94560";
                ctx.shadowColor = '#e94560';
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.closePath();
                ctx.shadowBlur = 0;
            }

            function drawBricks() {
                for (let c = 0; c < brickInfo.columnCount; c++) {
                    for (let r = 0; r < bricks[c].length; r++) {
                        const b = bricks[c][r];
                        if (b.status === 1) {
                            ctx.beginPath();
                            ctx.rect(b.x, b.y, brickInfo.width, brickInfo.height);
                            // Change color based on health
                            ctx.fillStyle = b.health > 1 ? '#bdc3c7' : b.baseColor;
                            ctx.fill();
                            ctx.closePath();
                        }
                    }
                }
            }

            function drawParticles() {
                particles.forEach((p, index) => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.alpha;
                    ctx.fill();
                    ctx.closePath();
                });
                ctx.globalAlpha = 1;
            }

            function drawPowerUps() {
                powerUps.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.font = 'bold 20px "Press Start 2P"';
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 15;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(p.type, p.x, p.y);
                });
                 ctx.shadowBlur = 0;
                 ctx.textAlign = 'left';
                 ctx.textBaseline = 'alphabetic';
            }


            // --- Update & Logic Functions ---
            function moveBalls() {
                balls.forEach(ball => {
                    ball.x += ball.dx;
                    ball.y += ball.dy;
                });
            }

            function updateParticles() {
                particles.forEach((p, index) => {
                    p.x += p.dx;
                    p.y += p.dy;
                    p.life--;
                    p.alpha = p.life / 50;
                    if (p.life <= 0) {
                        particles.splice(index, 1);
                    }
                });
            }

            function updatePowerUps() {
                powerUps.forEach((p, index) => {
                    p.y += p.dy;
                    // Collision with paddle
                    if (p.y + p.size > paddle.y && p.x > paddle.x && p.x < paddle.x + paddle.width) {
                        activatePowerUp(p.type);
                        powerUps.splice(index, 1);
                    }
                    // Remove if off-screen
                    if (p.y > canvas.height) {
                        powerUps.splice(index, 1);
                    }
                });
            }

            function activatePowerUp(type) {
                powerupSound();
                if (type === 'W') { // Widen paddle
                    paddle.width = paddle.baseWidth * 1.5;
                    setTimeout(() => { paddle.width = paddle.baseWidth; }, 8000); // Revert after 8 seconds
                } else if (type === 'M') { // Multi-ball
                     if (balls.length < 5) { // Cap at 5 balls
                        const newBall = createBall(paddle.x + paddle.width / 2, paddle.y - 20, -balls[0].dx, -balls[0].dy, balls[0].speed);
                        balls.push(newBall);
                     }
                }
            }

            function collisionDetection() {
                balls.forEach((ball, index) => {
                    // Wall collisions
                    if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
                        ball.dx = -ball.dx;
                        wallSound();
                    }
                    if (ball.y + ball.dy < ball.radius) {
                        ball.dy = -ball.dy;
                        wallSound();
                    }

                    // Paddle collision
                    if (ball.y + ball.dy > paddle.y - ball.radius && ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                        let collidePoint = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                        let angle = collidePoint * (Math.PI / 3);
                        ball.dx = ball.speed * Math.sin(angle);
                        ball.dy = -ball.speed * Math.cos(angle);
                        paddleSound();
                    } 
                    // Bottom wall collision (lose life / ball)
                    else if (ball.y + ball.dy > canvas.height - ball.radius) {
                        if (balls.length > 1) {
                            balls.splice(index, 1);
                        } else {
                            lives--;
                            loseLifeSound();
                            if (lives <= 0) {
                                gameState = 'gameOver';
                                showModal('Game Over', `Your final score is ${score}.`, 'Play Again');
                            } else {
                                gameState = 'paused';
                                resetBallAndPaddle();
                                livesElement.textContent = lives;
                            }
                        }
                    }

                    // Brick collision
                    for (let c = 0; c < brickInfo.columnCount; c++) {
                        for (let r = 0; r < bricks[c].length; r++) {
                            const b = bricks[c][r];
                            if (b.status === 1) {
                                if (ball.x > b.x && ball.x < b.x + brickInfo.width && ball.y > b.y && ball.y < b.y + brickInfo.height) {
                                    ball.dy = -ball.dy;
                                    b.health--;
                                    if (b.health <= 0) {
                                        b.status = 0;
                                        score += 10;
                                        createParticles(b.x + brickInfo.width / 2, b.y + brickInfo.height / 2, b.health > 1 ? '#bdc3c7' : b.baseColor);
                                        hitSound();
                                        // Chance to drop a power-up
                                        if (Math.random() < 0.2) { // 20% chance
                                            createPowerUp(b.x + brickInfo.width / 2, b.y + brickInfo.height / 2);
                                        }
                                        checkWinCondition();
                                    } else {
                                        strongHitSound();
                                    }
                                    scoreElement.textContent = score;
                                    return; // Exit brick loop for this ball
                                }
                            }
                        }
                    }
                });
            }

            function checkWinCondition() {
                const totalBricks = brickInfo.rowCount * brickInfo.columnCount;
                let brokenBricks = 0;
                bricks.forEach(column => column.forEach(brick => {
                    if (brick.status === 0) brokenBricks++;
                }));

                if (brokenBricks === totalBricks) {
                    gameState = 'levelComplete';
                    score += 1000; // Level clear bonus
                    showModal('You Win!', `Bonus +1000! Total: ${score}`, 'Next Level');
                }
            }

            // --- Main Game Loop ---
            function draw() {
                drawBallTrail(); // Creates the motion blur effect
                drawBricks();
                drawParticles();
                drawPowerUps();
                drawPaddle();
                drawBalls();
            }

            function update() {
                if (gameState === 'playing') {
                    moveBalls();
                    collisionDetection();
                    updateParticles();
                    updatePowerUps();
                }
            }

            function gameLoop() {
                update();
                draw();
                if (gameState !== 'gameOver' && gameState !== 'levelComplete') {
                   animationFrameId = requestAnimationFrame(gameLoop);
                } else {
                   cancelAnimationFrame(animationFrameId);
                }
            }

            // --- Controls & UI ---
            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const relativeX = (e.clientX - rect.left) * scaleX;
                if (relativeX > 0 && relativeX < canvas.width) {
                    paddle.x = relativeX - paddle.width / 2;
                    if (paddle.x < 0) paddle.x = 0;
                    if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
                }
            }

            function handleTouchMove(e) {
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    handleMouseMove(touch);
                }
            }

            function showModal(title, message, buttonText) {
                modalTitle.textContent = title;
                modalMessage.textContent = message;
                modalButton.textContent = buttonText;
                gameModal.style.display = 'flex';
                cancelAnimationFrame(animationFrameId);
            }

            function resetGame(startPlaying) {
                 if (gameState === 'gameOver') {
                    score = 0;
                    lives = 3;
                 }
                 if(gameState === 'levelComplete'){
                    lives++; // Bonus life for completing a level
                 }

                 // Reset game elements
                 paddle.baseWidth = canvas.width / 7;
                 paddle.height = canvas.height / 30;
                 paddle.y = canvas.height - paddle.height - 15;

                 brickInfo.width = (canvas.width - brickInfo.offsetLeft * 2 - brickInfo.padding * (brickInfo.columnCount - 1)) / brickInfo.columnCount;
                 brickInfo.height = canvas.height / 35;

                 resetBallAndPaddle();
                 createBricks();
                 particles = [];
                 powerUps = [];

                 scoreElement.textContent = score;
                 livesElement.textContent = lives;

                 if (startPlaying) {
                    gameState = 'playing';
                    gameModal.style.display = 'none';
                    gameLoop();
                 } else {
                    draw(); // Draw initial state but don't start loop
                 }
            }

            modalButton.addEventListener('click', () => {
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }
                resetGame(true);
            });

            // --- Initial Load ---
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            window.addEventListener('resize', resizeCanvas);

            resizeCanvas();
            showModal('Brick Breaker', 'Use your mouse or finger to move the paddle.', 'Start Game');
        });
    </script>
</body>
</html>
